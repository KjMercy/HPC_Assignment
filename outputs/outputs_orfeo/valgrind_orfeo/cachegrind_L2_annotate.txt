--------------------------------------------------------------------------------
-- Metadata
--------------------------------------------------------------------------------
Invocation:       /usr/bin/cg_annotate --auto=yes --show=Dr,D1mr,DLmr,Bc,Bcm /u/ipauser/kj_mersimoski/outputs_valgrind/cachegrind_L2.out
I1 cache:         32768 B, 64 B, 8-way associative
D1 cache:         32768 B, 64 B, 8-way associative
LL cache:         524288 B, 64 B, 8-way associative
Command:          ./stencil_parallel -x 512 -y 512 -o 0 -v 0 -n 100
Events recorded:  Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw Bc Bcm Bi Bim
Events shown:     Dr D1mr DLmr Bc Bcm
Event sort order: Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw Bc Bcm Bi Bim
Threshold:        0.1%
Annotation:       on

--------------------------------------------------------------------------------
-- Summary
--------------------------------------------------------------------------------
Dr__________________ D1mr______________ DLmr______________ Bc_________________ Bcm_____________ 

161,591,952 (100.0%) 4,611,037 (100.0%) 3,653,761 (100.0%) 78,353,384 (100.0%) 738,528 (100.0%)  PROGRAM TOTALS

--------------------------------------------------------------------------------
-- File:function summary
--------------------------------------------------------------------------------
  Dr________________________ D1mr____________________ DLmr____________________ Bc_______________________ Bcm___________________  file:function

< 131,094,851 (81.1%, 81.1%) 3,456,026 (75.0%, 75.0%) 3,429,602 (93.9%, 93.9%) 52,127,354 (66.5%, 66.5%)  52,192  (7.1%,  7.1%)  /u/ipauser/kj_mersimoski/HPC_Assignment/src/stencil_template_parallel.c:
  130,055,600 (80.5%)        3,324,241 (72.1%)        3,315,180 (90.7%)        52,020,800 (66.4%)         51,234  (6.9%)           update_inner_plane._omp_fn.0
      517,200  (0.3%)           91,600  (2.0%)           80,162  (2.2%)            52,800  (0.1%)            502  (0.1%)           update_border_plane._omp_fn.0
      516,800  (0.3%)           39,350  (0.9%)           33,850  (0.9%)            52,400  (0.1%)            414  (0.1%)           update_border_plane._omp_fn.1

<  22,480,678 (13.9%, 95.0%)   835,825 (18.1%, 93.1%)    84,550  (2.3%, 96.2%) 21,075,003 (26.9%, 93.4%) 524,949 (71.1%, 78.1%)  ???:
    2,156,129  (1.3%)          288,638  (6.3%)            4,320  (0.1%)         1,060,277  (1.4%)         98,854 (13.4%)           __strcmp_avx2
        5,064  (0.0%)              254  (0.0%)               37  (0.0%)         6,749,267  (8.6%)          1,655  (0.2%)           __memset_avx2_unaligned_erms
    2,049,337  (1.3%)            1,025  (0.0%)              291  (0.0%)         1,161,325  (1.5%)         23,249  (3.1%)           __vfscanf_internal
      903,564  (0.6%)            9,171  (0.2%)            1,738  (0.0%)           845,199  (1.1%)         32,567  (4.4%)           _int_malloc
    1,899,004  (1.2%)           14,287  (0.3%)            2,073  (0.1%)         1,273,913  (1.6%)         25,922  (3.5%)           getenv
    1,056,852  (0.7%)           14,172  (0.3%)            9,087  (0.2%)           711,500  (0.9%)          7,128  (1.0%)           _int_free
    1,080,572  (0.7%)          296,434  (6.4%)            1,243  (0.0%)         1,027,038  (1.3%)          5,070  (0.7%)           client_connect_to_shmem2_from_buffi
      643,560  (0.4%)              782  (0.0%)              145  (0.0%)           355,886  (0.5%)          8,478  (1.1%)           __printf_buffer
      424,424  (0.3%)              438  (0.0%)              125  (0.0%)           609,172  (0.8%)         30,854  (4.2%)           ____strtoul_l_internal
      749,713  (0.5%)            2,608  (0.1%)              511  (0.0%)           568,729  (0.7%)         17,106  (2.3%)           malloc
      547,480  (0.3%)                1  (0.0%)                1  (0.0%)           358,131  (0.5%)         21,304  (2.9%)           __strspn_generic
    1,209,907  (0.7%)           20,000  (0.4%)              636  (0.0%)         1,219,488  (1.6%)         48,065  (6.5%)           __memcpy_avx_unaligned_erms
    1,428,527  (0.9%)           16,977  (0.4%)            6,060  (0.2%)               141  (0.0%)             54  (0.0%)           ???
      609,929  (0.4%)            9,609  (0.2%)            5,851  (0.2%)           243,862  (0.3%)          5,212  (0.7%)           free
      516,097  (0.3%)                0                        0                   194,068  (0.2%)          3,902  (0.5%)           __printf_buffer_write
      283,515  (0.2%)            1,235  (0.0%)              341  (0.0%)           253,633  (0.3%)         12,588  (1.7%)           __strncmp_avx2
      399,841  (0.2%)                1  (0.0%)                0                   240,638  (0.3%)            459  (0.1%)           fgets
      312,873  (0.2%)           36,877  (0.8%)           10,531  (0.3%)           204,100  (0.3%)         12,052  (1.6%)           malloc_consolidate
      317,117  (0.2%)                0                        0                   131,840  (0.2%)          1,175  (0.2%)           _IO_getline_info
      192,633  (0.1%)           23,093  (0.5%)            5,816  (0.2%)           164,502  (0.2%)         10,954  (1.5%)           __strlen_avx2
      340,660  (0.2%)               20  (0.0%)                2  (0.0%)           138,967  (0.2%)          4,091  (0.6%)           pmix41_bfrops_base_unpack_general_int
      152,909  (0.1%)               81  (0.0%)               45  (0.0%)           162,236  (0.2%)          7,146  (1.0%)           __strspn_sse42
       92,428  (0.1%)              227  (0.0%)                0                    88,013  (0.1%)            764  (0.1%)           flex128_decode_int

<   1,983,223  (1.2%, 96.3%)    80,050  (1.7%, 94.8%)    10,966  (0.3%, 96.5%)  1,037,274  (1.3%, 94.7%)  35,968  (4.9%, 83.0%)  /usr/src/debug/glibc-2.40-24.fc41.x86_64/elf/dl-lookup.c:
    1,557,255  (1.0%)           72,031  (1.6%)            8,155  (0.2%)           876,595  (1.1%)         30,317  (4.1%)           do_lookup_x
      281,403  (0.2%)              934  (0.0%)              117  (0.0%)           101,240  (0.1%)          2,141  (0.3%)           _dl_lookup_symbol_x

<     263,796  (0.2%, 96.4%)    33,437  (0.7%, 95.5%)    33,101  (0.9%, 97.4%)    524,900  (0.7%, 95.4%)     527  (0.1%, 83.1%)  /u/ipauser/kj_mersimoski/HPC_Assignment/include/stencil_template_parallel.h:
      262,192  (0.2%)           32,912  (0.7%)           32,743  (0.9%)           524,300  (0.7%)            522  (0.1%)           get_total_energy._omp_fn.0

<     196,494  (0.1%, 96.6%)     8,438  (0.2%, 95.7%)     4,571  (0.1%, 97.5%)    196,494  (0.3%, 95.7%)   9,739  (1.3%, 84.4%)  /usr/src/debug/glibc-2.40-24.fc41.x86_64/elf/../sysdeps/generic/dl-new-hash.h:_dl_lookup_symbol_x

<     180,209  (0.1%, 96.7%)        13  (0.0%, 95.7%)         7  (0.0%, 97.5%)    198,521  (0.3%, 95.9%)  10,834  (1.5%, 85.9%)  /u/builder/builder/.jenkins/workspace/Builder/hwloc/build/hwloc/hwloc/topology-xml-nolibxml.c:
      148,274  (0.1%)                0                        0                   185,863  (0.2%)          9,338  (1.3%)           hwloc__nolibxml_import_next_attr

<     156,904  (0.1%, 96.8%)        86  (0.0%, 95.7%)        34  (0.0%, 97.5%)     55,339  (0.1%, 96.0%)      53  (0.0%, 85.9%)  /usr/src/debug/ucx-1.17.0-3.fc41.x86_64/src/ucs/sys/event_set.c:
      156,531  (0.1%)               65  (0.0%)               22  (0.0%)            55,247  (0.1%)             40  (0.0%)           ucs_event_set_wait

--------------------------------------------------------------------------------
-- Function:file summary
--------------------------------------------------------------------------------
  Dr________________________ D1mr____________________ DLmr____________________ Bc_______________________ Bcm__________________  function:file

> 130,055,600 (80.5%, 80.5%) 3,324,241 (72.1%, 72.1%) 3,315,180 (90.7%, 90.7%) 52,020,800 (66.4%, 66.4%) 51,234  (6.9%,  6.9%)  update_inner_plane._omp_fn.0:/u/ipauser/kj_mersimoski/HPC_Assignment/src/stencil_template_parallel.c

>   2,156,129  (1.3%, 81.8%)   288,638  (6.3%, 78.4%)     4,320  (0.1%, 90.9%)  1,060,277  (1.4%, 67.7%) 98,854 (13.4%, 20.3%)  __strcmp_avx2:???

>       5,064  (0.0%, 81.8%)       254  (0.0%, 78.4%)        37  (0.0%, 90.9%)  6,749,267  (8.6%, 76.4%)  1,655  (0.2%, 20.5%)  __memset_avx2_unaligned_erms:???

>   2,049,337  (1.3%, 83.1%)     1,025  (0.0%, 78.4%)       291  (0.0%, 90.9%)  1,161,325  (1.5%, 77.8%) 23,249  (3.1%, 23.7%)  __vfscanf_internal:???

>     903,564  (0.6%, 83.6%)     9,171  (0.2%, 78.6%)     1,738  (0.0%, 90.9%)    845,199  (1.1%, 78.9%) 32,567  (4.4%, 28.1%)  _int_malloc:???

>   1,576,586  (1.0%, 84.6%)    72,031  (1.6%, 80.1%)     8,155  (0.2%, 91.1%)    885,412  (1.1%, 80.1%) 30,342  (4.1%, 32.2%)  do_lookup_x:
    1,557,255  (1.0%)           72,031  (1.6%)            8,155  (0.2%)           876,595  (1.1%)        30,317  (4.1%)           /usr/src/debug/glibc-2.40-24.fc41.x86_64/elf/dl-lookup.c

>   1,899,004  (1.2%, 85.8%)    14,287  (0.3%, 80.5%)     2,073  (0.1%, 91.2%)  1,273,913  (1.6%, 81.7%) 25,922  (3.5%, 35.7%)  getenv:???

>   1,056,852  (0.7%, 86.5%)    14,172  (0.3%, 80.8%)     9,087  (0.2%, 91.4%)    711,500  (0.9%, 82.6%)  7,128  (1.0%, 36.7%)  _int_free:???

>   1,080,572  (0.7%, 87.1%)   296,434  (6.4%, 87.2%)     1,243  (0.0%, 91.5%)  1,027,038  (1.3%, 83.9%)  5,070  (0.7%, 37.4%)  client_connect_to_shmem2_from_buffi:???

>     643,560  (0.4%, 87.5%)       782  (0.0%, 87.2%)       145  (0.0%, 91.5%)    355,886  (0.5%, 84.3%)  8,478  (1.1%, 38.5%)  __printf_buffer:???

>     262,192  (0.2%, 87.7%)    32,912  (0.7%, 87.9%)    32,743  (0.9%, 92.4%)    524,300  (0.7%, 85.0%)    522  (0.1%, 38.6%)  get_total_energy._omp_fn.0:/u/ipauser/kj_mersimoski/HPC_Assignment/include/stencil_template_parallel.h

>     424,424  (0.3%, 87.9%)       438  (0.0%, 87.9%)       125  (0.0%, 92.4%)    609,172  (0.8%, 85.8%) 30,854  (4.2%, 42.8%)  ____strtoul_l_internal:???

>     749,713  (0.5%, 88.4%)     2,608  (0.1%, 88.0%)       511  (0.0%, 92.4%)    568,729  (0.7%, 86.5%) 17,106  (2.3%, 45.1%)  malloc:???

>     547,480  (0.3%, 88.7%)         1  (0.0%, 88.0%)         1  (0.0%, 92.4%)    358,131  (0.5%, 87.0%) 21,304  (2.9%, 48.0%)  __strspn_generic:???

>   1,209,907  (0.7%, 89.5%)    20,000  (0.4%, 88.4%)       636  (0.0%, 92.4%)  1,219,488  (1.6%, 88.5%) 48,065  (6.5%, 54.5%)  __memcpy_avx_unaligned_erms:???

>     477,897  (0.3%, 89.8%)     9,372  (0.2%, 88.6%)     4,688  (0.1%, 92.5%)    297,734  (0.4%, 88.9%) 11,880  (1.6%, 56.1%)  _dl_lookup_symbol_x:
      196,494  (0.1%)            8,438  (0.2%)            4,571  (0.1%)           196,494  (0.3%)         9,739  (1.3%)           /usr/src/debug/glibc-2.40-24.fc41.x86_64/elf/../sysdeps/generic/dl-new-hash.h
      281,403  (0.2%)              934  (0.0%)              117  (0.0%)           101,240  (0.1%)         2,141  (0.3%)           /usr/src/debug/glibc-2.40-24.fc41.x86_64/elf/dl-lookup.c

>   1,428,527  (0.9%, 90.7%)    16,977  (0.4%, 89.0%)     6,060  (0.2%, 92.7%)        141  (0.0%, 88.9%)     54  (0.0%, 56.1%)  ???:???

>     609,929  (0.4%, 91.1%)     9,609  (0.2%, 89.2%)     5,851  (0.2%, 92.9%)    243,862  (0.3%, 89.2%)  5,212  (0.7%, 56.8%)  free:???

>     516,097  (0.3%, 91.4%)         0  (0.0%, 89.2%)         0  (0.0%, 92.9%)    194,068  (0.2%, 89.5%)  3,902  (0.5%, 57.3%)  __printf_buffer_write:???

>     517,200  (0.3%, 91.7%)    91,600  (2.0%, 91.2%)    80,162  (2.2%, 95.1%)     52,800  (0.1%, 89.5%)    502  (0.1%, 57.4%)  update_border_plane._omp_fn.0:/u/ipauser/kj_mersimoski/HPC_Assignment/src/stencil_template_parallel.c

>     516,800  (0.3%, 92.0%)    39,350  (0.9%, 92.0%)    33,850  (0.9%, 96.0%)     52,400  (0.1%, 89.6%)    414  (0.1%, 57.5%)  update_border_plane._omp_fn.1:/u/ipauser/kj_mersimoski/HPC_Assignment/src/stencil_template_parallel.c

>     283,515  (0.2%, 92.2%)     1,235  (0.0%, 92.1%)       341  (0.0%, 96.0%)    253,633  (0.3%, 89.9%) 12,588  (1.7%, 59.2%)  __strncmp_avx2:???

>     399,841  (0.2%, 92.4%)         1  (0.0%, 92.1%)         0  (0.0%, 96.0%)    240,638  (0.3%, 90.2%)    459  (0.1%, 59.2%)  fgets:???

>     312,873  (0.2%, 92.6%)    36,877  (0.8%, 92.9%)    10,531  (0.3%, 96.3%)    204,100  (0.3%, 90.5%) 12,052  (1.6%, 60.9%)  malloc_consolidate:???

>     317,117  (0.2%, 92.8%)         0  (0.0%, 92.9%)         0  (0.0%, 96.3%)    131,840  (0.2%, 90.7%)  1,175  (0.2%, 61.0%)  _IO_getline_info:???

>     192,633  (0.1%, 92.9%)    23,093  (0.5%, 93.4%)     5,816  (0.2%, 96.4%)    164,502  (0.2%, 90.9%) 10,954  (1.5%, 62.5%)  __strlen_avx2:???

>     148,274  (0.1%, 93.0%)         0  (0.0%, 93.4%)         0  (0.0%, 96.4%)    185,863  (0.2%, 91.1%)  9,338  (1.3%, 63.8%)  hwloc__nolibxml_import_next_attr:/u/builder/builder/.jenkins/workspace/Builder/hwloc/build/hwloc/hwloc/topology-xml-nolibxml.c

>     340,660  (0.2%, 93.2%)        20  (0.0%, 93.4%)         2  (0.0%, 96.4%)    138,967  (0.2%, 91.3%)  4,091  (0.6%, 64.3%)  pmix41_bfrops_base_unpack_general_int:???

>     152,909  (0.1%, 93.3%)        81  (0.0%, 93.4%)        45  (0.0%, 96.4%)    162,236  (0.2%, 91.5%)  7,146  (1.0%, 65.3%)  __strspn_sse42:???

>      92,428  (0.1%, 93.4%)       227  (0.0%, 93.4%)         0  (0.0%, 96.4%)     88,013  (0.1%, 91.6%)    764  (0.1%, 65.4%)  flex128_decode_int:???

>     156,531  (0.1%, 93.5%)        65  (0.0%, 93.4%)        22  (0.0%, 96.4%)     55,247  (0.1%, 91.7%)     40  (0.0%, 65.4%)  ucs_event_set_wait:/usr/src/debug/ucx-1.17.0-3.fc41.x86_64/src/ucs/sys/event_set.c

--------------------------------------------------------------------------------
-- Annotated source file: /u/builder/builder/.jenkins/workspace/Builder/hwloc/build/hwloc/hwloc/topology-xml-nolibxml.c
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /u/builder/builder/.jenkins/workspace/Builder/hwloc/build/hwloc/hwloc/topology-xml-nolibxml.c

--------------------------------------------------------------------------------
-- Annotated source file: /u/ipauser/kj_mersimoski/HPC_Assignment/include/stencil_template_parallel.h
--------------------------------------------------------------------------------
Dr____________ D1mr_________ DLmr_________ Bc____________ Bcm_______ 

-- line 109 ----------------------------------------
      .             .             .              .          .         
      .             .             .              .          .         inline int inject_energy(const int periodic,
      .             .             .              .          .                                  const int Nsources,
      .             .             .              .          .                                  const vec2_t *Sources,
      .             .             .              .          .                                  const double energy,
      .             .             .              .          .                                  plane_t *plane,
      .             .             .              .          .                                  const vec2_t N)
      .             .             .              .          .         {
    100 (0.0%)     25 (0.0%)      0              0          0             const uint register sizex = plane->size[_x_] + 2;
      1 (0.0%)      0             0              0          0             double *restrict data = plane->data;
      .             .             .              .          .         
      .             .             .              .          .         #define IDX(i, j) ((j) * sizex + (i))
    300 (0.0%)      0             0            600 (0.0%)   5 (0.0%)      for (int s = 0; s < Nsources; s++)
      .             .             .              .          .             {
      .             .             .              .          .                 int x = Sources[s][_x_];
      .             .             .              .          .                 int y = Sources[s][_y_];
      .             .             .              .          .         
  1,200 (0.0%)    499 (0.0%)    358 (0.0%)       0          0                 data[IDX(x, y)] += energy;
      .             .             .              .          .         
      .             .             .              .          .                 if (periodic)
      .             .             .              .          .                 {
      .             .             .              .          .                     if ((N[_x_] == 1))
      .             .             .              .          .                     {
      .             .             .              .          .                         // propagate the boundaries if needed
      .             .             .              .          .                         // check the serial version
      .             .             .              .          .                         // TODO: da vedere se Ã¨ meglio branchless con fprofile
-- line 134 ----------------------------------------
-- line 233 ----------------------------------------
      .             .             .              .          .         inline int get_total_energy(plane_t *plane,
      .             .             .              .          .                                     double *energy)
      .             .             .              .          .         /*
      .             .             .              .          .          * NOTE: this routine a good candiadate for openmp
      .             .             .              .          .          *       parallelization
      .             .             .              .          .          */
      .             .             .              .          .         {
      .             .             .              .          .         
      1 (0.0%)      1 (0.0%)      0              0          0             const int register xsize = plane->size[_x_];
      .             .             .              .          .             const int register ysize = plane->size[_y_];
      0             0             0              0          0             const int register fsize = xsize + 2;
      .             .             .              .          .         
      1 (0.0%)      0             0              0          0             double *restrict data = plane->data;
      .             .             .              .          .         
      .             .             .              .          .         #define IDX(i, j) ((j) * fsize + (i))
      .             .             .              .          .         
      .             .             .              .          .         #if defined(LONG_ACCURACY)
      .             .             .              .          .             long double totenergy = 0;
      .             .             .              .          .         #else
      .             .             .              .          .             double totenergy = 0;
      .             .             .              .          .         #endif
      .             .             .              .          .         
      .             .             .              .          .         // HINT: you may attempt to
      .             .             .              .          .         //       (i)  manually unroll the loop
      .             .             .              .          .         //       (ii) ask the compiler to do it
      .             .             .              .          .         // for instance
      .             .             .              .          .         // #pragma GCC unroll 4
     49 (0.0%)     12 (0.0%)     12 (0.0%)       8 (0.0%)   1 (0.0%)  #pragma omp parallel for reduction(+ : totenergy) collapse(2) schedule(static)
      .             .             .              .          .             for (int j = 1; j <= ysize; j++)
      0             0             0              8 (0.0%)   1 (0.0%)          for (int i = 1; i <= xsize; i++)
262,144 (0.2%) 32,900 (0.7%) 32,731 (0.9%) 524,284 (0.7%) 520 (0.1%)              totenergy += data[IDX(i, j)];
      .             .             .              .          .         
      .             .             .              .          .         #undef IDX
      .             .             .              .          .         
      0             0             0              0          0             *energy = (double)totenergy;
      .             .             .              .          .             return 0;
      .             .             .              .          .         }
      .             .             .              .          .         
      .             .             .              .          .         extern int dump(const double *data, const uint size[2], const char *filename)

--------------------------------------------------------------------------------
-- Annotated source file: /u/ipauser/kj_mersimoski/HPC_Assignment/src/stencil_template_parallel.c
--------------------------------------------------------------------------------
Dr_________________ D1mr_____________ DLmr_____________ Bc________________ Bcm__________ 

-- line 9 ----------------------------------------
          .                 .                 .                  .              .         
          .                 .                 .                  .              .         #include "stencil_template_parallel.h"
          .                 .                 .                  .              .         #include <immintrin.h>
          .                 .                 .                  .              .         
          .                 .                 .                  .              .         // ------------------------------------------------------------------
          .                 .                 .                  .              .         // ------------------------------------------------------------------
          .                 .                 .                  .              .         
          .                 .                 .                  .              .         int main(int argc, char **argv)
         99  (0.0%)        99  (0.0%)        99  (0.0%)          0              0         {
          .                 .                 .                  .              .           MPI_Comm myCOMM_WORLD;
          .                 .                 .                  .              .           int Rank, Ntasks;
          .                 .                 .                  .              .           uint neighbours[4];
          .                 .                 .                  .              .         
          .                 .                 .                  .              .           int Niterations;
          .                 .                 .                  .              .           int periodic;
          .                 .                 .                  .              .           vec2_t S, N; // dimensioni griglia globale e dimensioni griglia processi
          .                 .                 .                  .              .         
-- line 25 ----------------------------------------
-- line 34 ----------------------------------------
          .                 .                 .                  .              .           int output_energy_stat_perstep;
          .                 .                 .                  .              .         
          .                 .                 .                  .              .           /* initialize MPI envrionment */
          .                 .                 .                  .              .           {
          .                 .                 .                  .              .             int level_obtained;
          .                 .                 .                  .              .         
          .                 .                 .                  .              .             // NOTE: change MPI_FUNNELED if appropriate
          .                 .                 .                  .              .             //
          0                 0                 0                  0              0             MPI_Init_thread(&argc, &argv, MPI_THREAD_FUNNELED, &level_obtained);
          1  (0.0%)         1  (0.0%)         1  (0.0%)          1  (0.0%)      0             if (level_obtained < MPI_THREAD_FUNNELED)
          .                 .                 .                  .              .             {
          .                 .                 .                  .              .               printf("MPI_thread level obtained is %d instead of %d\n",
          .                 .                 .                  .              .                      level_obtained, MPI_THREAD_FUNNELED);
          .                 .                 .                  .              .               MPI_Finalize();
          .                 .                 .                  .              .               exit(1);
          .                 .                 .                  .              .             }
          .                 .                 .                  .              .         
          0                 0                 0                  0              0             MPI_Comm_rank(MPI_COMM_WORLD, &Rank);
          0                 0                 0                  0              0             MPI_Comm_size(MPI_COMM_WORLD, &Ntasks);
          0                 0                 0                  0              0             MPI_Comm_dup(MPI_COMM_WORLD, &myCOMM_WORLD);
          .                 .                 .                  .              .           }
          .                 .                 .                  .              .         
          .                 .                 .                  .              .           /* argument checking and setting */
          6  (0.0%)         0                 0                  0              0           int ret = initialize(&myCOMM_WORLD, Rank, Ntasks, argc, argv, &S, &N, &periodic, &output_energy_stat_perstep,
          .                 .                 .                  .              .                                neighbours, &Niterations,
          .                 .                 .                  .              .                                &Nsources, &Nsources_local, &Sources_local, &energy_per_source,
          .                 .                 .                  .              .                                &planes[0], &buffers[0]);
          .                 .                 .                  .              .           // notice that passing &planes or &planes[0] is the same
          .                 .                 .                  .              .           // thing since they are arrays/pointers
          .                 .                 .                  .              .         
          0                 0                 0                  1  (0.0%)      0           if (ret)
          .                 .                 .                  .              .           {
          .                 .                 .                  .              .             printf("task %d is opting out with termination code %d\n",
          .                 .                 .                  .              .                    Rank, ret);
          .                 .                 .                  .              .         
          .                 .                 .                  .              .             MPI_Finalize();
          .                 .                 .                  .              .             return 0;
          .                 .                 .                  .              .           }
          .                 .                 .                  .              .         
          .                 .                 .                  .              .           int current = OLD;
          0                 0                 0                  0              0           double t1 = MPI_Wtime(); /* take wall-clock time */
          0                 0                 0                  0              0           double comm_time = 0;
          .                 .                 .                  .              .         
        301  (0.0%)         0                 0                101  (0.0%)      2 (0.0%)    for (int iter = 0; iter < Niterations; ++iter)
          .                 .                 .                  .              .         
          .                 .                 .                  .              .           {
          .                 .                 .                  .              .         
          .                 .                 .                  .              .             MPI_Request reqs[8];
          .                 .                 .                  .              .             /* new energy from sources */
          2  (0.0%)         0                 0                  0              0             inject_energy(periodic, Nsources_local, Sources_local, energy_per_source, &planes[current], N);
          .                 .                 .                  .              .         
          .                 .                 .                  .              .             /* -------------------------------------- */
          .                 .                 .                  .              .         
          .                 .                 .                  .              .             // [A] fill the buffers, and/or make the buffers' pointers pointing to the correct position
          .                 .                 .                  .              .         
        100  (0.0%)         0                 0                  0              0             fill_buffers(&planes[current], buffers, planes[current].size, neighbours);
          .                 .                 .                  .              .         
          .                 .                 .                  .              .             // [B] perfoem the halo communications
          .                 .                 .                  .              .             //     (1) use Send / Recv
          .                 .                 .                  .              .             //     (2) use Isend / Irecv
          .                 .                 .                  .              .             //         --> can you overlap communication and compution in this way?
          0                 0                 0                  0              0             double temp1 = MPI_Wtime();
        100  (0.0%)         0                 0                  0              0             perform_halo_comms(buffers, neighbours, &myCOMM_WORLD, reqs, planes[current].size);
        200  (0.0%)         0                 0                  0              0             comm_time += (MPI_Wtime() - temp1);
          .                 .                 .                  .              .         
          .                 .                 .                  .              .             // Let's update INNER plane
        100  (0.0%)         0                 0                  0              0             update_inner_plane(&planes[current], &planes[!current]);
          .                 .                 .                  .              .         
          0                 0                 0                  0              0             temp1 = MPI_Wtime();
          .                 .                 .                  .              .             MPI_Status statuses[8];
        100  (0.0%)       100  (0.0%)       100  (0.0%)          0              0             MPI_Waitall(8, reqs, statuses);
          .                 .                 .                  .              .             // [C] copy the haloes data
          .                 .                 .                  .              .             copy_halo_data(&planes[current], buffers, planes[current].size, neighbours);
        200  (0.0%)       100  (0.0%)       100  (0.0%)          0              0             comm_time += (MPI_Wtime() - temp1);
          .                 .                 .                  .              .         
          .                 .                 .                  .              .             // Finally let's update BORDERs
          .                 .                 .                  .              .             update_border_plane(periodic, N, &planes[current], &planes[!current]);
          .                 .                 .                  .              .         
          .                 .                 .                  .              .             /* --------------------------------------  */
          .                 .                 .                  .              .             /* update grid points */
          .                 .                 .                  .              .         
          .                 .                 .                  .              .             // Commented to verify if overlapping the two works
          .                 .                 .                  .              .             // update_plane(periodic, N, &planes[current], &planes[!current]);
          .                 .                 .                  .              .         
          .                 .                 .                  .              .             /* output if needed */
        101  (0.0%)         0                 0                100  (0.0%)      2 (0.0%)      if (output_energy_stat_perstep)
        100  (0.0%)         0                 0                  0              0               output_energy_stat(iter, &planes[!current], (iter + 1) * Nsources * energy_per_source, Rank, &myCOMM_WORLD);
          .                 .                 .                  .              .         
          .                 .                 .                  .              .             /* --------------------------------------  */
          .                 .                 .                  .              .             /*  Dump of data for plotting
          .                 .                 .                  .              .                 Credits: Davide Zorzetto
          .                 .                 .                  .              .             */
          .                 .                 .                  .              .             // char filename[100];
          .                 .                 .                  .              .             // sprintf(filename, "./data_parallel/%d_plane_%05d.bin", Rank, iter);
          .                 .                 .                  .              .             // int dump_status = dump(planes[!current].data, planes[!current].size, filename);
-- line 128 ----------------------------------------
-- line 131 ----------------------------------------
          .                 .                 .                  .              .             //   fprintf(stderr, "Error in dump_status. Exit with %d\n", dump_status);
          .                 .                 .                  .              .             // }
          .                 .                 .                  .              .             /******************** */
          .                 .                 .                  .              .         
          .                 .                 .                  .              .             /* swap plane indexes for the new iteration */
          .                 .                 .                  .              .             current = !current;
          .                 .                 .                  .              .           }
          .                 .                 .                  .              .         
          1  (0.0%)         1  (0.0%)         0                  0              0           t1 = MPI_Wtime() - t1;
          1  (0.0%)         1  (0.0%)         1  (0.0%)          0              0           printf("---------Rank: %d \t Elapsed time:%.6f---------\n", Rank, t1);
          .                 .                 .                  .              .         
          7  (0.0%)         0                 0                  0              0           output_energy_stat(-1, &planes[!current], Niterations * Nsources * energy_per_source, Rank, &myCOMM_WORLD);
          .                 .                 .                  .              .         
          0                 0                 0                  0              0           memory_release(planes, buffers);
          .                 .                 .                  .              .         
          0                 0                 0                  0              0           double comms_sum = 0.0;
          0                 0                 0                  0              0           double total_time = 0.0;
          2  (0.0%)         1  (0.0%)         1  (0.0%)          0              0           MPI_Reduce(&comm_time, &comms_sum, 1, MPI_DOUBLE, MPI_SUM, 0, myCOMM_WORLD);
          1  (0.0%)         0                 0                  0              0           MPI_Reduce(&t1, &total_time, 1, MPI_DOUBLE, MPI_SUM, 0, myCOMM_WORLD);
          .                 .                 .                  .              .         
          3  (0.0%)         0                 0                  1  (0.0%)      1 (0.0%)    if (Rank == 0)
          .                 .                 .                  .              .           {
          .                 .                 .                  .              .             int P;
          1  (0.0%)         0                 0                  0              0             MPI_Comm_size(myCOMM_WORLD, &P);
          0                 0                 0                  0              0             printf("Total time,Comms time\n");
          3  (0.0%)         0                 0                  0              0             printf("%.6f,%.6f\n\n", total_time/(double)P, comms_sum/(double)P);
          .                 .                 .                  .              .           }
          .                 .                 .                  .              .         
          0                 0                 0                  0              0           MPI_Finalize();
          .                 .                 .                  .              .           return 0;
          7  (0.0%)         1  (0.0%)         1  (0.0%)          0              0         }
          .                 .                 .                  .              .         
          .                 .                 .                  .              .         /* ==========================================================================
          .                 .                 .                  .              .            =                                                                        =
          .                 .                 .                  .              .            =   routines called within the integration loop                          =
          .                 .                 .                  .              .            ========================================================================== */
          .                 .                 .                  .              .         
          .                 .                 .                  .              .         void fill_buffers(plane_t *plane, buffers_t *buffers, vec2_t size, int *neighbours)
          0                 0                 0                  0              0         {
        100  (0.0%)         0                 0                  0              0           uint fx = size[_x_] + 2;
        100  (0.0%)         0                 0                  0              0           uint fy = size[_y_];
          .                 .                 .                  .              .         
          .                 .                 .                  .              .         #define IDX(i, j) ((j) * fx + i)
          .                 .                 .                  .              .         
        100  (0.0%)        99  (0.0%)         0                100  (0.0%)      2 (0.0%)    if (neighbours[NORTH] != MPI_PROC_NULL)
          .                 .                 .                  .              .           {
          .                 .                 .                  .              .             buffers[SEND][NORTH] = &plane->data[IDX(1, 1)]; // first inner row
          .                 .                 .                  .              .             buffers[RECV][NORTH] = &plane->data[IDX(1, 0)]; // top ghost row
          .                 .                 .                  .              .           }
          .                 .                 .                  .              .         
        100  (0.0%)         0                 0                100  (0.0%)      2 (0.0%)    if (neighbours[SOUTH] != MPI_PROC_NULL)
          .                 .                 .                  .              .           {
          .                 .                 .                  .              .             buffers[SEND][SOUTH] = &plane->data[IDX(1, fy)];     // last inner row
          .                 .                 .                  .              .             buffers[RECV][SOUTH] = &plane->data[IDX(1, fy + 1)]; // top ghost row
          .                 .                 .                  .              .           }
          .                 .                 .                  .              .         
        100  (0.0%)         0                 0                100  (0.0%)      2 (0.0%)    if (neighbours[EAST] != MPI_PROC_NULL)
          .                 .                 .                  .              .           {
          .                 .                 .                  .              .             for (uint j = 0; j < size[_y_]; j++)
          .                 .                 .                  .              .             {
          .                 .                 .                  .              .               buffers[SEND][EAST][j] = plane->data[IDX(size[_x_], j + 1)];
          .                 .                 .                  .              .             }
          .                 .                 .                  .              .           }
          .                 .                 .                  .              .         
        100  (0.0%)         0                 0                100  (0.0%)      2 (0.0%)    if (neighbours[WEST] != MPI_PROC_NULL)
          .                 .                 .                  .              .           {
          .                 .                 .                  .              .             for (uint j = 0; j < size[_y_]; j++)
          .                 .                 .                  .              .             {
          .                 .                 .                  .              .               buffers[SEND][WEST][j] = plane->data[IDX(1, j + 1)];
          .                 .                 .                  .              .             }
          .                 .                 .                  .              .           }
          .                 .                 .                  .              .         
          .                 .                 .                  .              .         #undef IDX
        300  (0.0%)         0                 0                  0              0         }
          .                 .                 .                  .              .         
          .                 .                 .                  .              .         void perform_halo_comms(buffers_t *buffers, int *neighbours, MPI_Comm *comm, MPI_Request *reqs, vec2_t size)
        100  (0.0%)         0                 0                  0              0         {
        100  (0.0%)        25  (0.0%)         0                  0              0           for (uint i = 0; i < 8; i++)
          .                 .                 .                  .              .           {
          0                 0                 0                  0              0             reqs[i] = MPI_REQUEST_NULL;
          .                 .                 .                  .              .           }
          .                 .                 .                  .              .         
        100  (0.0%)         0                 0                100  (0.0%)      0           if (neighbours[NORTH] != MPI_PROC_NULL)
          .                 .                 .                  .              .           {
          .                 .                 .                  .              .             MPI_Irecv(buffers[RECV][NORTH], size[_x_], MPI_DOUBLE, neighbours[NORTH], 0, *comm, &reqs[0]);
          .                 .                 .                  .              .             MPI_Isend(buffers[SEND][NORTH], size[_x_], MPI_DOUBLE, neighbours[NORTH], 1, *comm, &reqs[1]);
          .                 .                 .                  .              .           }
          .                 .                 .                  .              .         
        100  (0.0%)         0                 0                100  (0.0%)      2 (0.0%)    if (neighbours[SOUTH] != MPI_PROC_NULL)
          .                 .                 .                  .              .           {
          .                 .                 .                  .              .             MPI_Irecv(buffers[RECV][SOUTH], size[_x_], MPI_DOUBLE, neighbours[SOUTH], 1, *comm, &reqs[2]);
          .                 .                 .                  .              .             MPI_Isend(buffers[SEND][SOUTH], size[_x_], MPI_DOUBLE, neighbours[SOUTH], 0, *comm, &reqs[3]);
          .                 .                 .                  .              .           }
          .                 .                 .                  .              .         
        100  (0.0%)         0                 0                100  (0.0%)      0           if (neighbours[EAST] != MPI_PROC_NULL)
          .                 .                 .                  .              .           {
          .                 .                 .                  .              .             MPI_Irecv(buffers[RECV][EAST], size[_y_], MPI_DOUBLE, neighbours[EAST], 2, *comm, &reqs[4]);
          .                 .                 .                  .              .             MPI_Isend(buffers[SEND][EAST], size[_y_], MPI_DOUBLE, neighbours[EAST], 3, *comm, &reqs[5]);
          .                 .                 .                  .              .           }
          .                 .                 .                  .              .         
        100  (0.0%)         0                 0                100  (0.0%)      0           if (neighbours[WEST] != MPI_PROC_NULL)
          .                 .                 .                  .              .           {
          .                 .                 .                  .              .             MPI_Irecv(buffers[RECV][WEST], size[_y_], MPI_DOUBLE, neighbours[WEST], 3, *comm, &reqs[6]);
          .                 .                 .                  .              .             MPI_Isend(buffers[SEND][WEST], size[_y_], MPI_DOUBLE, neighbours[WEST], 2, *comm, &reqs[7]);
          .                 .                 .                  .              .           }
        800  (0.0%)         0                 0                  0              0         }
          .                 .                 .                  .              .         
          .                 .                 .                  .              .         void copy_halo_data(plane_t *plane, buffers_t *buffers_ptr, vec2_t size, int *neighbours)
          .                 .                 .                  .              .         {
          .                 .                 .                  .              .           uint fx = size[_x_] + 2;
          .                 .                 .                  .              .         
          .                 .                 .                  .              .         #define IDX(i, j) ((j) * fx + i)
          .                 .                 .                  .              .         
        401  (0.0%)       100  (0.0%)       100  (0.0%)        100  (0.0%)      2 (0.0%)    if (neighbours[EAST] != MPI_PROC_NULL)
          .                 .                 .                  .              .           {
          .                 .                 .                  .              .             for (uint j = 0; j < size[_y_]; j++)
          .                 .                 .                  .              .             {
          .                 .                 .                  .              .               plane->data[IDX(size[_x_] + 1, j + 1)] = buffers_ptr[RECV][EAST][j];
          .                 .                 .                  .              .             }
          .                 .                 .                  .              .           }
          .                 .                 .                  .              .         
        102  (0.0%)         0                 0                100  (0.0%)      2 (0.0%)    if (neighbours[WEST] != MPI_PROC_NULL)
          .                 .                 .                  .              .           {
          0                 0                 0                  0              0             for (uint j = 0; j < size[_y_]; j++)
          .                 .                 .                  .              .             {
          .                 .                 .                  .              .               plane->data[IDX(0, j + 1)] = buffers_ptr[RECV][WEST][j];
          .                 .                 .                  .              .             }
          .                 .                 .                  .              .           }
          .                 .                 .                  .              .         
          .                 .                 .                  .              .         #undef IDX
          .                 .                 .                  .              .         }
          .                 .                 .                  .              .         
-- line 262 ----------------------------------------
-- line 306 ----------------------------------------
          .                 .                 .                  .              .         }
          .                 .                 .                  .              .         
          .                 .                 .                  .              .         inline double stencil_computation(const double *restrict old,
          .                 .                 .                  .              .                                           const uint fxsize,
          .                 .                 .                  .              .                                           const uint i,
          .                 .                 .                  .              .                                           const uint j)
          .                 .                 .                  .              .         {
          .                 .                 .                  .              .           const uint idx = j * fxsize + i;
104,859,200 (64.9%)    97,740  (2.1%)    87,338  (2.4%)          0              0           return old[idx] * 0.5 + (old[idx - 1] + old[idx + 1] +
 26,214,800 (16.2%) 3,354,271 (72.7%) 3,340,078 (91.4%)          0              0                                    old[idx - fxsize] + old[idx + fxsize]) *
          .                 .                 .                  .              .                                       0.125;
          .                 .                 .                  .              .         }
          .                 .                 .                  .              .         
          .                 .                 .                  .              .         inline int update_inner_plane_simd(const plane_t *oldplane,
          .                 .                 .                  .              .                                            plane_t *newplane)
          .                 .                 .                  .              .         // This code is left here for reference. I don't call this function since, after
          .                 .                 .                  .              .         // doing test on my local machine, it provided no speedup in the execution.
          .                 .                 .                  .              .         // This is because the compiler, with the flag -march=native, already implements
-- line 323 ----------------------------------------
-- line 370 ----------------------------------------
          .                 .                 .                  .              .         
          .                 .                 .                  .              .         inline int update_inner_plane(const plane_t *oldplane,
          .                 .                 .                  .              .                                       plane_t *newplane)
          .                 .                 .                  .              .         {
          .                 .                 .                  .              .           uint register fxsize = oldplane->size[_x_] + 2;
          .                 .                 .                  .              .           // uint register fysize = oldplane->size[_y_] + 2;
          .                 .                 .                  .              .         
          .                 .                 .                  .              .           uint register xsize = oldplane->size[_x_];
        100  (0.0%)         0                 0                  0              0           uint register ysize = oldplane->size[_y_];
          .                 .                 .                  .              .         
          .                 .                 .                  .              .         #define IDX(i, j) ((j) * fxsize + (i))
          .                 .                 .                  .              .         
          .                 .                 .                  .              .           double *restrict old = oldplane->data;
        100  (0.0%)         0                 0                  0              0           double *restrict new = newplane->data;
          .                 .                 .                  .              .         
      4,900  (0.0%)       996  (0.0%)       992  (0.0%)          0              0         #pragma omp parallel for collapse(2) schedule(static)
          .                 .                 .                  .              .           for (uint j = 2; j <= ysize - 1; j++)
        800  (0.0%)       616  (0.0%)       584  (0.0%)      1,200  (0.0%)     14 (0.0%)      for (uint i = 2; i <= xsize - 1; i++)
          0                 0                 0         52,019,600 (66.4%) 51,220 (6.9%)        new[IDX(i, j)] = stencil_computation(old, fxsize, i, j);
          .                 .                 .                  .              .         
          .                 .                 .                  .              .         #undef IDX
          .                 .                 .                  .              .           return 0;
          .                 .                 .                  .              .         }
          .                 .                 .                  .              .         
          .                 .                 .                  .              .         inline int update_border_plane(const int periodic,
          .                 .                 .                  .              .                                        const vec2_t N,
          .                 .                 .                  .              .                                        const plane_t *oldplane,
-- line 396 ----------------------------------------
-- line 400 ----------------------------------------
          .                 .                 .                  .              .           // uint register fysize = oldplane->size[_y_] + 2;
          .                 .                 .                  .              .         
          .                 .                 .                  .              .           uint register xsize = oldplane->size[_x_];
          .                 .                 .                  .              .           uint register ysize = oldplane->size[_y_];
          .                 .                 .                  .              .         
          .                 .                 .                  .              .         #define IDX(i, j) ((j) * fxsize + (i))
          .                 .                 .                  .              .         
          .                 .                 .                  .              .           double *restrict old = oldplane->data;
          0                 0                 0                  0              0           double *restrict new = newplane->data;
          .                 .                 .                  .              .         
      5,400  (0.0%)     1,056  (0.0%)       200  (0.0%)      1,600  (0.0%)     91 (0.0%)  #pragma omp parallel for schedule(static)
          .                 .                 .                  .              .           for (uint j = 1; j <= ysize; j++)
          .                 .                 .                  .              .           {
          0                 0                 0                  0              0             new[IDX(1, j)] = stencil_computation(old, fxsize, 1, j);         // left border
          0                 0                 0             51,200  (0.1%)    411 (0.1%)      new[IDX(xsize, j)] = stencil_computation(old, fxsize, xsize, j); // right border
          .                 .                 .                  .              .           }
          .                 .                 .                  .              .         
      4,100  (0.0%)       493  (0.0%)         0              1,200  (0.0%)      9 (0.0%)  #pragma omp parallel for schedule(static)
          .                 .                 .                  .              .           for (uint i = 1; i <= xsize; i++)
          .                 .                 .                  .              .           {
          0                 0                 0                  0              0             new[IDX(i, 1)] = stencil_computation(old, fxsize, i, 1);         // top border
        800  (0.0%)       119  (0.0%)         0             51,200  (0.1%)    405 (0.1%)      new[IDX(i, ysize)] = stencil_computation(old, fxsize, i, ysize); // bottom border
          .                 .                 .                  .              .           }
          .                 .                 .                  .              .         
          .                 .                 .                  .              .           // If periodic, wrap
        300  (0.0%)       200  (0.0%)         0                100  (0.0%)      2 (0.0%)    if (periodic)
          .                 .                 .                  .              .           {
          .                 .                 .                  .              .             if (N[_x_] == 1)
          .                 .                 .                  .              .             {
          .                 .                 .                  .              .               for (uint j = 1; j <= ysize; j++)
          .                 .                 .                  .              .               {
          .                 .                 .                  .              .                 new[IDX(0, j)] = new[IDX(xsize, j)];     // left ghost <-- right inner boundary
          .                 .                 .                  .              .                 new[IDX(xsize + 1, j)] = new[IDX(1, j)]; // right ghost <-- left inner boundary
          .                 .                 .                  .              .               }
-- line 433 ----------------------------------------
-- line 479 ----------------------------------------
          .                 .                 .                  .              .                        int *neighbours,  // four-int array that gives back the neighbours of the calling task
          .                 .                 .                  .              .                        int *Niterations, // how many iterations
          .                 .                 .                  .              .                        int *Nsources,    // how many heat sources
          .                 .                 .                  .              .                        int *Nsources_local,
          .                 .                 .                  .              .                        vec2_t **Sources_local,
          .                 .                 .                  .              .                        double *energy_per_source, // how much heat per source
          .                 .                 .                  .              .                        plane_t *planes,
          .                 .                 .                  .              .                        buffers_t *buffers)
         11  (0.0%)         0                 0                  0              0         {
          0                 0                 0                  0              0           int halt = 0;
          .                 .                 .                  .              .           int ret;
          0                 0                 0                  0              0           int verbose = 0;
          .                 .                 .                  .              .         
          .                 .                 .                  .              .           // Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
          .                 .                 .                  .              .           // set deffault values
          .                 .                 .                  .              .         
          1  (0.0%)         1  (0.0%)         1  (0.0%)          0              0           (*S)[_x_] = 10000;
          .                 .                 .                  .              .           (*S)[_y_] = 10000;
          0                 0                 0                  0              0           *periodic = 0;
          0                 0                 0                  0              0           *Nsources = 4;
          0                 0                 0                  0              0           *Nsources_local = 0;
          0                 0                 0                  0              0           *Sources_local = NULL;
          0                 0                 0                  0              0           *Niterations = 1000;
          1  (0.0%)         0                 0                  0              0           *energy_per_source = 1.0;
          .                 .                 .                  .              .         
          0                 0                 0                  1  (0.0%)      0           if (planes == NULL)
          .                 .                 .                  .              .           {
          .                 .                 .                  .              .             // manage the situation
          .                 .                 .                  .              .             fprintf(stderr, "Unable to allocate memory for `planes`; It has NULL value");
          .                 .                 .                  .              .             return 1;
          .                 .                 .                  .              .           }
          .                 .                 .                  .              .         
          .                 .                 .                  .              .           // Original version: WRONG
          .                 .                 .                  .              .           // planes[OLD].size[0] = planes[OLD].size[0] = 0;
          .                 .                 .                  .              .           // planes[NEW].size[0] = planes[NEW].size[0] = 0;
          0                 0                 0                  0              0           planes[OLD].size[0] = planes[OLD].size[1] = 0;
          0                 0                 0                  0              0           planes[NEW].size[0] = planes[NEW].size[1] = 0;
          .                 .                 .                  .              .         
          .                 .                 .                  .              .           for (int i = 0; i < 4; i++)
          1  (0.0%)         0                 0                  0              0             neighbours[i] = MPI_PROC_NULL;
          .                 .                 .                  .              .         
          0                 0                 0                  0              0           for (int b = 0; b < 2; b++)
          .                 .                 .                  .              .             for (int d = 0; d < 4; d++)
          1  (0.0%)         0                 0                  0              0               buffers[b][d] = NULL;
          .                 .                 .                  .              .         
          .                 .                 .                  .              .           // Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
          .                 .                 .                  .              .           // process the commadn line
          .                 .                 .                  .              .           //
          .                 .                 .                  .              .           while (1)
          .                 .                 .                  .              .           {
          .                 .                 .                  .              .             int opt;
          0                 0                 0                  6  (0.0%)      1 (0.0%)      while ((opt = getopt(argc, argv, ":hx:y:e:E:n:o:p:v:")) != -1)
          .                 .                 .                  .              .             {
          5  (0.0%)         2  (0.0%)         2  (0.0%)          5  (0.0%)      1 (0.0%)        switch (opt)
          .                 .                 .                  .              .               {
          .                 .                 .                  .              .               case 'x':
          0                 0                 0                  0              0                 (*S)[_x_] = (uint)atoi(optarg);
          0                 0                 0                  0              0                 break;
          .                 .                 .                  .              .         
          .                 .                 .                  .              .               case 'y':
          0                 0                 0                  0              0                 (*S)[_y_] = (uint)atoi(optarg);
          0                 0                 0                  0              0                 break;
          .                 .                 .                  .              .         
          .                 .                 .                  .              .               case 'e':
          .                 .                 .                  .              .                 *Nsources = atoi(optarg);
          .                 .                 .                  .              .                 break;
          .                 .                 .                  .              .         
          .                 .                 .                  .              .               case 'E':
          .                 .                 .                  .              .                 *energy_per_source = atof(optarg);
          .                 .                 .                  .              .                 break;
          .                 .                 .                  .              .         
          .                 .                 .                  .              .               case 'n':
          .                 .                 .                  .              .                 *Niterations = atoi(optarg);
          0                 0                 0                  0              0                 break;
          .                 .                 .                  .              .         
          .                 .                 .                  .              .               case 'o':
          0                 0                 0                  0              0                 *output_energy_stat = (atoi(optarg) > 0);
          0                 0                 0                  0              0                 break;
          .                 .                 .                  .              .         
          .                 .                 .                  .              .               case 'p':
          .                 .                 .                  .              .                 *periodic = (atoi(optarg) > 0);
          .                 .                 .                  .              .                 break;
          .                 .                 .                  .              .         
          .                 .                 .                  .              .               case 'v':
          .                 .                 .                  .              .                 verbose = atoi(optarg);
          0                 0                 0                  0              0                 break;
          .                 .                 .                  .              .         
          .                 .                 .                  .              .               case 'h':
          .                 .                 .                  .              .               {
          .                 .                 .                  .              .                 if (Me == 0)
          .                 .                 .                  .              .                   printf("\nvalid options are ( values btw [] are the default values ):\n"
          .                 .                 .                  .              .                          "-x    x size of the plate [10000]\n"
          .                 .                 .                  .              .                          "-y    y size of the plate [10000]\n"
          .                 .                 .                  .              .                          "-e    how many energy sources on the plate [4]\n"
-- line 572 ----------------------------------------
-- line 586 ----------------------------------------
          .                 .                 .                  .              .                 break;
          .                 .                 .                  .              .               }
          .                 .                 .                  .              .             }
          .                 .                 .                  .              .         
          .                 .                 .                  .              .             if (opt == -1)
          .                 .                 .                  .              .               break;
          .                 .                 .                  .              .           }
          .                 .                 .                  .              .         
          1  (0.0%)         0                 0                  1  (0.0%)      1 (0.0%)    if (halt)
          .                 .                 .                  .              .             return 1;
          .                 .                 .                  .              .         
          .                 .                 .                  .              .           // Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
          .                 .                 .                  .              .           /*
          .                 .                 .                  .              .            * here we should check for all the parms being meaningful
          .                 .                 .                  .              .            *
          .                 .                 .                  .              .            *
          .                 .                 .                  .              .            */
          .                 .                 .                  .              .         
          2  (0.0%)         0                 0                  2  (0.0%)      1 (0.0%)    if ((*S)[_x_] <= 0 || (*S)[_y_] <= 0)
          .                 .                 .                  .              .           {
          .                 .                 .                  .              .             if (Me == 0)
          .                 .                 .                  .              .               fprintf(stderr, "Grid size must be positive\n");
          .                 .                 .                  .              .             return 1;
          .                 .                 .                  .              .           }
          .                 .                 .                  .              .         
          2  (0.0%)         0                 0                  2  (0.0%)      1 (0.0%)    if (*Nsources <= 0 || *Nsources > (int)((*S)[_x_] * (*S)[_y_]))
          .                 .                 .                  .              .           {
          .                 .                 .                  .              .             if (Me == 0)
          .                 .                 .                  .              .               fprintf(stderr, "Invalid number of sources: must be 0 < Nsources < gridsize\n");
          .                 .                 .                  .              .             return 1;
          .                 .                 .                  .              .           }
          .                 .                 .                  .              .         
          2  (0.0%)         0                 0                  1  (0.0%)      0           if (*Niterations <= 0)
          .                 .                 .                  .              .           {
          .                 .                 .                  .              .             if (Me == 0)
          .                 .                 .                  .              .               fprintf(stderr, "Number of iterations must be positive\n");
          .                 .                 .                  .              .             return 1;
          .                 .                 .                  .              .           }
          .                 .                 .                  .              .         
          2  (0.0%)         0                 0                  1  (0.0%)      0           if (*energy_per_source <= 0.0)
          .                 .                 .                  .              .           {
          .                 .                 .                  .              .             if (Me == 0)
          .                 .                 .                  .              .               fprintf(stderr, "Energy per source must be positive\n");
          .                 .                 .                  .              .             return 1;
          .                 .                 .                  .              .           }
          .                 .                 .                  .              .         
          .                 .                 .                  .              .           // ...
          .                 .                 .                  .              .         
-- line 633 ----------------------------------------
-- line 637 ----------------------------------------
          .                 .                 .                  .              .            * very simple algorithm, you may want to
          .                 .                 .                  .              .            * substitute it with a better one
          .                 .                 .                  .              .            *
          .                 .                 .                  .              .            * the plane Sx x Sy will be solved with a grid
          .                 .                 .                  .              .            * of Nx x Ny MPI tasks
          .                 .                 .                  .              .            */
          .                 .                 .                  .              .         
          .                 .                 .                  .              .           vec2_t Grid;
          0                 0                 0                  1  (0.0%)      1 (0.0%)    double formfactor = ((*S)[_x_] >= (*S)[_y_] ? (double)(*S)[_x_] / (*S)[_y_] : (double)(*S)[_y_] / (*S)[_x_]);
          1  (0.0%)         0                 0                  1  (0.0%)      1 (0.0%)    int dimensions = 2 - (Ntasks <= ((int)formfactor + 1));
          .                 .                 .                  .              .         
          .                 .                 .                  .              .           if (dimensions == 1)
          .                 .                 .                  .              .           {
          .                 .                 .                  .              .             if ((*S)[_x_] >= (*S)[_y_])
          0                 0                 0                  0              0               Grid[_x_] = Ntasks, Grid[_y_] = 1;
          .                 .                 .                  .              .             else
          .                 .                 .                  .              .               Grid[_x_] = 1, Grid[_y_] = Ntasks;
          .                 .                 .                  .              .           }
          .                 .                 .                  .              .           else
          .                 .                 .                  .              .           {
          .                 .                 .                  .              .             int Nf;
          .                 .                 .                  .              .             uint *factors;
          .                 .                 .                  .              .             uint first = 1;
-- line 659 ----------------------------------------
-- line 663 ----------------------------------------
          .                 .                 .                  .              .               first *= factors[i];
          .                 .                 .                  .              .         
          .                 .                 .                  .              .             if ((*S)[_x_] > (*S)[_y_])
          .                 .                 .                  .              .               Grid[_x_] = Ntasks / first, Grid[_y_] = first;
          .                 .                 .                  .              .             else
          .                 .                 .                  .              .               Grid[_x_] = first, Grid[_y_] = Ntasks / first;
          .                 .                 .                  .              .           }
          .                 .                 .                  .              .         
          1  (0.0%)         0                 0                  0              0           (*N)[_x_] = Grid[_x_];
          0                 0                 0                  0              0           (*N)[_y_] = Grid[_y_];
          .                 .                 .                  .              .         
          .                 .                 .                  .              .           // Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
          .                 .                 .                  .              .           // my cooridnates in the grid of processors
          .                 .                 .                  .              .           //
          0                 0                 0                  0              0           int X = Me % Grid[_x_];
          0                 0                 0                  0              0           int Y = Me / Grid[_x_];
          .                 .                 .                  .              .         
          .                 .                 .                  .              .           // Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
          .                 .                 .                  .              .           // find my neighbours
          .                 .                 .                  .              .           //
          .                 .                 .                  .              .         
          0                 0                 0                  1  (0.0%)      1 (0.0%)    if (Grid[_x_] > 1)
          .                 .                 .                  .              .           {
          .                 .                 .                  .              .             if (*periodic)
          .                 .                 .                  .              .             {
          .                 .                 .                  .              .               neighbours[EAST] = Y * Grid[_x_] + (Me + 1) % Grid[_x_];
          .                 .                 .                  .              .               neighbours[WEST] = (X % Grid[_x_] > 0 ? Me - 1 : (Y + 1) * Grid[_x_] - 1);
          .                 .                 .                  .              .             }
          .                 .                 .                  .              .         
          .                 .                 .                  .              .             else
-- line 692 ----------------------------------------
-- line 718 ----------------------------------------
          .                 .                 .                  .              .           /*
          .                 .                 .                  .              .            * every MPI task determines the size sx x sy of its own domain
          .                 .                 .                  .              .            * REMIND: the computational domain will be embedded into a frame
          .                 .                 .                  .              .            *         that is (sx+2) x (sy+2)
          .                 .                 .                  .              .            *         the outern frame will be used for halo communication or
          .                 .                 .                  .              .            */
          .                 .                 .                  .              .         
          .                 .                 .                  .              .           vec2_t mysize;
          1  (0.0%)         0                 0                  0              0           uint s = (*S)[_x_] / Grid[_x_];
          .                 .                 .                  .              .           uint r = (*S)[_x_] % Grid[_x_];
          0                 0                 0                  0              0           mysize[_x_] = s + (X < r);
          1  (0.0%)         0                 0                  0              0           s = (*S)[_y_] / Grid[_y_];
          .                 .                 .                  .              .           r = (*S)[_y_] % Grid[_y_];
          0                 0                 0                  0              0           mysize[_y_] = s + (Y < r);
          .                 .                 .                  .              .         
          1  (0.0%)         0                 0                  0              0           planes[OLD].size[0] = mysize[0];
          0                 0                 0                  0              0           planes[OLD].size[1] = mysize[1];
          0                 0                 0                  0              0           planes[NEW].size[0] = mysize[0];
          0                 0                 0                  0              0           planes[NEW].size[1] = mysize[1];
          .                 .                 .                  .              .         
          1  (0.0%)         0                 0                  1  (0.0%)      1 (0.0%)    if (verbose > 0)
          .                 .                 .                  .              .           {
          .                 .                 .                  .              .             if (Me == 0)
          .                 .                 .                  .              .             {
          .                 .                 .                  .              .               printf("Tasks are decomposed in a grid %d x %d\n\n",
          .                 .                 .                  .              .                      Grid[_x_], Grid[_y_]);
          .                 .                 .                  .              .               fflush(stdout);
          .                 .                 .                  .              .             }
          .                 .                 .                  .              .         
-- line 746 ----------------------------------------
-- line 761 ----------------------------------------
          .                 .                 .                  .              .         
          .                 .                 .                  .              .               MPI_Barrier(*Comm);
          .                 .                 .                  .              .             }
          .                 .                 .                  .              .           }
          .                 .                 .                  .              .         
          .                 .                 .                  .              .           // Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
          .                 .                 .                  .              .           // allocae the needed memory
          .                 .                 .                  .              .           //
          4  (0.0%)         0                 0                  0              0           ret = memory_allocate(neighbours, *N, buffers, planes);
          .                 .                 .                  .              .         
          .                 .                 .                  .              .           // Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
          .                 .                 .                  .              .           // allocae the heat sources
          .                 .                 .                  .              .           //
          6  (0.0%)         0                 0                  0              0           ret = initialize_sources(Me, Ntasks, Comm, mysize, *Nsources, Nsources_local, Sources_local);
          .                 .                 .                  .              .         
          2  (0.0%)         0                 0                  0              0           return 0;
          9  (0.0%)         0                 0                  0              0         }
          .                 .                 .                  .              .         
          .                 .                 .                  .              .         uint simple_factorization(uint A, int *Nfactors, uint **factors)
          .                 .                 .                  .              .         /*
          .                 .                 .                  .              .          * rought factorization;
          .                 .                 .                  .              .          * assumes that A is small, of the order of <~ 10^5 max,
          .                 .                 .                  .              .          * since it represents the number of tasks
          .                 .                 .                  .              .          #
          .                 .                 .                  .              .          */
          .                 .                 .                  .              .         {
          .                 .                 .                  .              .           int N = 0;
          .                 .                 .                  .              .           int f = 2;
          .                 .                 .                  .              .           uint _A_ = A;
          .                 .                 .                  .              .         
          0                 0                 0                  0              0           while (f < A)
          .                 .                 .                  .              .           {
          .                 .                 .                  .              .             while (_A_ % f == 0)
          .                 .                 .                  .              .             {
          .                 .                 .                  .              .               N++;
          .                 .                 .                  .              .               _A_ /= f;
          .                 .                 .                  .              .             }
          .                 .                 .                  .              .         
          .                 .                 .                  .              .             f++;
-- line 799 ----------------------------------------
-- line 823 ----------------------------------------
          .                 .                 .                  .              .         int initialize_sources(int Me,
          .                 .                 .                  .              .                                int Ntasks,
          .                 .                 .                  .              .                                MPI_Comm *Comm,
          .                 .                 .                  .              .                                vec2_t mysize,
          .                 .                 .                  .              .                                int Nsources,
          .                 .                 .                  .              .                                int *Nsources_local,
          .                 .                 .                  .              .                                vec2_t **Sources)
          .                 .                 .                  .              .         
          0                 0                 0                  0              0         {
          .                 .                 .                  .              .         
          0                 0                 0                  0              0           srand48(time(NULL) ^ Me);
          0                 0                 0                  0              0           int *tasks_with_sources = (int *)malloc(Nsources * sizeof(int));
          .                 .                 .                  .              .         
          0                 0                 0                  1  (0.0%)      1 (0.0%)    if (Me == 0)
          .                 .                 .                  .              .           {
          5  (0.0%)         0                 0                  5  (0.0%)      3 (0.0%)      for (int i = 0; i < Nsources; i++)
          4  (0.0%)         0                 0                  0              0               tasks_with_sources[i] = (int)lrand48() % Ntasks;
          .                 .                 .                  .              .           }
          .                 .                 .                  .              .         
          2  (0.0%)         0                 0                  0              0           MPI_Bcast(tasks_with_sources, Nsources, MPI_INT, 0, *Comm);
          .                 .                 .                  .              .         
          0                 0                 0                  0              0           int nlocal = 0;
          0                 0                 0                  2  (0.0%)      1 (0.0%)    for (int i = 0; i < Nsources; i++)
          1  (0.0%)         0                 0                  1  (0.0%)      1 (0.0%)      nlocal += (tasks_with_sources[i] == Me);
          1  (0.0%)         0                 0                  0              0           *Nsources_local = nlocal;
          .                 .                 .                  .              .         
          0                 0                 0                  1  (0.0%)      0           if (nlocal > 0)
          .                 .                 .                  .              .           {
          0                 0                 0                  0              0             vec2_t *restrict helper = (vec2_t *)malloc(nlocal * sizeof(vec2_t));
          0                 0                 0                  4  (0.0%)      4 (0.0%)      for (int s = 0; s < nlocal; s++)
          .                 .                 .                  .              .             {
          4  (0.0%)         0                 0                  0              0               helper[s][_x_] = 1 + lrand48() % mysize[_x_];
          4  (0.0%)         0                 0                  0              0               helper[s][_y_] = 1 + lrand48() % mysize[_y_];
          .                 .                 .                  .              .             }
          .                 .                 .                  .              .         
          1  (0.0%)         0                 0                  0              0             *Sources = helper; // TODO liberalo nel memory release
          .                 .                 .                  .              .           }
          .                 .                 .                  .              .         
          0                 0                 0                  0              0           free(tasks_with_sources);
          .                 .                 .                  .              .         
          .                 .                 .                  .              .           return 0;
          7  (0.0%)         0                 0                  0              0         }
          .                 .                 .                  .              .         
          .                 .                 .                  .              .         int memory_allocate(const int *neighbours,
          .                 .                 .                  .              .                             const vec2_t N,
          .                 .                 .                  .              .                             buffers_t *buffers_ptr,
          .                 .                 .                  .              .                             plane_t *planes_ptr)
          0                 0                 0                  0              0         {
          .                 .                 .                  .              .           /*
          .                 .                 .                  .              .             here you allocate the memory buffers that you need to
          .                 .                 .                  .              .             (i)  hold the results of your computation
          .                 .                 .                  .              .             (ii) communicate with your neighbours
          .                 .                 .                  .              .         
          .                 .                 .                  .              .             The memory layout that I propose to you is as follows:
          .                 .                 .                  .              .         
          .                 .                 .                  .              .             (i) --- calculations
-- line 878 ----------------------------------------
-- line 902 ----------------------------------------
          .                 .                 .                  .              .         
          .                 .                 .                  .              .             (*buffers_ptr)[SEND][ {NORTH,...,WEST} ] = .. some memory regions
          .                 .                 .                  .              .             (*buffers_ptr)[RECV][ {NORTH,...,WEST} ] = .. some memory regions
          .                 .                 .                  .              .         
          .                 .                 .                  .              .             --->> Of course you can change this layout as you prefer
          .                 .                 .                  .              .         
          .                 .                 .                  .              .            */
          .                 .                 .                  .              .         
          0                 0                 0                  1  (0.0%)      0           if (planes_ptr == NULL)
          .                 .                 .                  .              .           {
          .                 .                 .                  .              .             // an invalid pointer has been passed
          .                 .                 .                  .              .             // manage the situation
          .                 .                 .                  .              .             fprintf(stderr, "Passed planes_ptr=NULL to memory_allocate function");
          .                 .                 .                  .              .             return 1;
          .                 .                 .                  .              .           }
          .                 .                 .                  .              .         
          0                 0                 0                  1  (0.0%)      0           if (buffers_ptr == NULL)
          .                 .                 .                  .              .           {
          .                 .                 .                  .              .             // an invalid pointer has been passed
          .                 .                 .                  .              .             // manage the situation
          .                 .                 .                  .              .             fprintf(stderr, "Passed buffers_ptr=NULL to memory_allocate function");
          .                 .                 .                  .              .             return 1;
          .                 .                 .                  .              .           }
          .                 .                 .                  .              .         
          .                 .                 .                  .              .           // Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
          .                 .                 .                  .              .           // allocate memory for data
          .                 .                 .                  .              .           // we allocate the space needed for the plane plus a contour frame
          .                 .                 .                  .              .           // that will contains data form neighbouring MPI tasks
          2  (0.0%)         0                 0                  0              0           unsigned int frame_size = (planes_ptr[OLD].size[_x_] + 2) * (planes_ptr[OLD].size[_y_] + 2);
          .                 .                 .                  .              .         
          0                 0                 0                  0              0           planes_ptr[OLD].data = (double *)malloc(frame_size * sizeof(double));
          0                 0                 0                  1  (0.0%)      0           if (planes_ptr[OLD].data == NULL)
          .                 .                 .                  .              .           {
          .                 .                 .                  .              .             // manage the malloc fail
          .                 .                 .                  .              .             fprintf(stderr, "Error allocating planes_ptr[OLD].data");
          .                 .                 .                  .              .             return 1;
          .                 .                 .                  .              .           }
          .                 .                 .                  .              .           memset(planes_ptr[OLD].data, 0, frame_size * sizeof(double));
          .                 .                 .                  .              .         
          0                 0                 0                  0              0           planes_ptr[NEW].data = (double *)malloc(frame_size * sizeof(double));
          0                 0                 0                  1  (0.0%)      0           if (planes_ptr[NEW].data == NULL)
          .                 .                 .                  .              .           {
          .                 .                 .                  .              .             // manage the malloc fail
          .                 .                 .                  .              .             fprintf(stderr, "Error allocating planes_ptr[NEW].data");
          .                 .                 .                  .              .             return 1;
          .                 .                 .                  .              .           }
          .                 .                 .                  .              .           memset(planes_ptr[NEW].data, 0, frame_size * sizeof(double));
          .                 .                 .                  .              .         
          .                 .                 .                  .              .           // Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
-- line 950 ----------------------------------------
-- line 970 ----------------------------------------
          .                 .                 .                  .              .           // #define IDX(i, j) (j * (buffer_size[_x_] + 2) + i)
          .                 .                 .                  .              .         
          .                 .                 .                  .              .           //   buffers_ptr[SEND][NORTH] = &planes_ptr[OLD].data[IDX(1, 1)];                // first inner row
          .                 .                 .                  .              .           //   buffers_ptr[SEND][SOUTH] = &planes_ptr[OLD].data[IDX(1, buffer_size[_y_])]; // last inner row
          .                 .                 .                  .              .         
          .                 .                 .                  .              .           //   buffers_ptr[RECV][NORTH] = &planes_ptr[OLD].data[IDX(1, 0)];                    // top ghost row
          .                 .                 .                  .              .           //   buffers_ptr[RECV][SOUTH] = &planes_ptr[OLD].data[IDX(1, buffer_size[_y_] + 1)]; // top ghost row
          .                 .                 .                  .              .           // #undef IDX
          0                 0                 0                  0              0           buffers_ptr[SEND][EAST] = malloc(buffer_size[_y_] * sizeof(double));
          0                 0                 0                  1  (0.0%)      0           if (buffers_ptr[SEND][EAST] == NULL)
          .                 .                 .                  .              .           {
          .                 .                 .                  .              .             fprintf(stderr, "Error allocating buffers_ptr[SEND][EAST]");
          .                 .                 .                  .              .             return 1;
          .                 .                 .                  .              .           }
          0                 0                 0                  0              0           buffers_ptr[SEND][WEST] = malloc(buffer_size[_y_] * sizeof(double));
          0                 0                 0                  1  (0.0%)      0           if (buffers_ptr[SEND][WEST] == NULL)
          .                 .                 .                  .              .           {
          .                 .                 .                  .              .             fprintf(stderr, "Error allocating buffers_ptr[SEND][WEST]");
          .                 .                 .                  .              .             return 1;
          .                 .                 .                  .              .           }
          0                 0                 0                  0              0           buffers_ptr[RECV][EAST] = malloc(buffer_size[_y_] * sizeof(double));
          0                 0                 0                  1  (0.0%)      0           if (buffers_ptr[RECV][EAST] == NULL)
          .                 .                 .                  .              .           {
          .                 .                 .                  .              .             fprintf(stderr, "Error allocating buffers_ptr[RECV][EAST]");
          .                 .                 .                  .              .             return 1;
          .                 .                 .                  .              .           }
          0                 0                 0                  0              0           buffers_ptr[RECV][WEST] = malloc(buffer_size[_y_] * sizeof(double));
          0                 0                 0                  1  (0.0%)      1 (0.0%)    if (buffers_ptr[RECV][WEST] == NULL)
          .                 .                 .                  .              .           {
          .                 .                 .                  .              .             fprintf(stderr, "Error allocating buffers_ptr[RECV][WEST]");
          .                 .                 .                  .              .             return 1;
          .                 .                 .                  .              .           }
          .                 .                 .                  .              .         
          .                 .                 .                  .              .           // Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
          .                 .                 .                  .              .         
          0                 0                 0                  0              0           return 0;
          6  (0.0%)         0                 0                  0              0         }
          .                 .                 .                  .              .         
          .                 .                 .                  .              .         int memory_release(plane_t *planes, buffers_t *buffers)
          0                 0                 0                  0              0         {
          .                 .                 .                  .              .         
          0                 0                 0                  1  (0.0%)      1 (0.0%)    if (planes != NULL)
          .                 .                 .                  .              .           {
          1  (0.0%)         0                 0                  1  (0.0%)      0             if (planes[OLD].data != NULL)
          0                 0                 0                  0              0               free(planes[OLD].data);
          .                 .                 .                  .              .         
          1  (0.0%)         0                 0                  1  (0.0%)      0             if (planes[NEW].data != NULL)
          0                 0                 0                  0              0               free(planes[NEW].data);
          .                 .                 .                  .              .           }
          .                 .                 .                  .              .         
          .                 .                 .                  .              .           return 0;
          3  (0.0%)         0                 0                  0              0         }
          .                 .                 .                  .              .         
          .                 .                 .                  .              .         int output_energy_stat(int step, plane_t *plane, double budget, int Me, MPI_Comm *Comm)
          0                 0                 0                  0              0         {
          .                 .                 .                  .              .         
          0                 0                 0                  0              0           double system_energy = 0;
          0                 0                 0                  0              0           double tot_system_energy = 0;
          .                 .                 .                  .              .           get_total_energy(plane, &system_energy);
          .                 .                 .                  .              .         
          1  (0.0%)         1  (0.0%)         1  (0.0%)          0              0           MPI_Reduce(&system_energy, &tot_system_energy, 1, MPI_DOUBLE, MPI_SUM, 0, *Comm);
          .                 .                 .                  .              .         
          2  (0.0%)         0                 0                  1  (0.0%)      0           if (Me == 0)
          .                 .                 .                  .              .           {
          0                 0                 0                  1  (0.0%)      0             if (step >= 0)
          .                 .                 .                  .              .               printf(" [ step %4d ] ", step);
          1  (0.0%)         1  (0.0%)         1  (0.0%)          0              0             fflush(stdout);
          .                 .                 .                  .              .         
          2  (0.0%)         0                 0                  0              0             printf("total injected energy is %g, "
          .                 .                 .                  .              .                    "system energy is %g "
          .                 .                 .                  .              .                    "( in avg %g per grid point)\n",
          .                 .                 .                  .              .                    budget,
          .                 .                 .                  .              .                    tot_system_energy,
          1  (0.0%)         1  (0.0%)         1  (0.0%)          0              0                    tot_system_energy / (plane->size[_x_] * plane->size[_y_]));
          .                 .                 .                  .              .           }
          .                 .                 .                  .              .         
          .                 .                 .                  .              .           return 0;
          7  (0.0%)         1  (0.0%)         1  (0.0%)          0              0         }
          .                 .                 .                  .              .         
          .                 .                 .                  .              .         /*
          .                 .                 .                  .              .             Dump of the data for plotting.
          .                 .                 .                  .              .             Credits: Davide Zorzetto
          .                 .                 .                  .              .         */
          .                 .                 .                  .              .         int dump(const double *data, const uint size[2], const char *filename)
          .                 .                 .                  .              .         {
          .                 .                 .                  .              .           if ((filename != NULL) && (filename[0] != '\0'))
-- line 1055 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /usr/src/debug/glibc-2.40-24.fc41.x86_64/elf/../sysdeps/generic/dl-new-hash.h
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /usr/src/debug/glibc-2.40-24.fc41.x86_64/elf/../sysdeps/generic/dl-new-hash.h

--------------------------------------------------------------------------------
-- Annotated source file: /usr/src/debug/glibc-2.40-24.fc41.x86_64/elf/dl-lookup.c
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /usr/src/debug/glibc-2.40-24.fc41.x86_64/elf/dl-lookup.c

--------------------------------------------------------------------------------
-- Annotated source file: /usr/src/debug/ucx-1.17.0-3.fc41.x86_64/src/ucs/sys/event_set.c
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /usr/src/debug/ucx-1.17.0-3.fc41.x86_64/src/ucs/sys/event_set.c

--------------------------------------------------------------------------------
-- Annotation summary
--------------------------------------------------------------------------------
Dr_________________ D1mr_____________ DLmr_____________ Bc________________ Bcm____________ 

131,358,647 (81.3%) 3,489,463 (75.7%) 3,462,703 (94.8%) 52,652,254 (67.2%)  52,719  (7.1%)    annotated: files known & above threshold & readable, line numbers known
          0                 0                 0                  0               0            annotated: files known & above threshold & readable, line numbers unknown
          0                 0                 0                  0               0          unannotated: files known & above threshold & two or more non-identical
  2,516,830  (1.6%)    88,587  (1.9%)    15,578  (0.4%)  1,487,628  (1.9%)  56,594  (7.7%)  unannotated: files known & above threshold & unreadable 
  5,235,797  (3.2%)   197,162  (4.3%)    90,930  (2.5%)  3,138,499  (4.0%) 104,266 (14.1%)  unannotated: files known & below threshold
 22,480,678 (13.9%)   835,825 (18.1%)    84,550  (2.3%) 21,075,003 (26.9%) 524,949 (71.1%)  unannotated: files unknown

